---
title: "How to map custom boundaries in Kibana with reverse geocoding"
date: "2021-03-03"
categories:
  - "category-ip-geolocation"
tags:
  - "elastic"
  - "geoip2"
  - "geolocation"
  - "integration"
---

**by Thomas Neirnyck
**This article was originally published on **[The Elastic Blog](https://www.elastic.co/blog/how-to-map-custom-boundaries-in-kibana-with-reverse-geocoding)** on Jan 20, 2021.

This tutorial shows how you can leverage GeoIP data using tools developed by Elastic. Elastic builds software to make data usable in real time and at scale for search, logging, security, and analytics use cases. Elastic's tools make it easier for operations teams to keep applications running, or give security professionals a one-stop-shop for spotting and neutralizing digital threats. Learn more at [elastic.co](http://www.elastic.co/).

Want to create a map of where your users are? With the GeoIP processor, you can easilyÂ [attach the location of your users to your user metrics](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/geoip-processor.html).Â 

Right out of the box, Kibana can map this traffic immediately by country or country subdivision:

![](images/blog-custom-map-boundaries-1-1024x364.jpg)

Plus, the newÂ [User Experience](https://www.elastic.co/blog/introducing-user-experience-monitoring-app-synthetic-capabilities)Â app for Elastic APM automatically creates maps based on monitoring data:

![](images/blog-custom-map-boundaries-2-1024x965.jpg)

But what if you want to take this one step further and create maps with different regions?

## Custom regions: metro area, proximity to IKEA, anything...

Elastic Maps come with a lot of great region options so you can get started quickly, but it also offers the ability toÂ **easily map your own regions**. You can use any boundary data you'd like for this, as long as you have source data that contains a longitude and latitude.Â 

For this example, suppose we use GeoIP, which is built into Elasticsearch. GeoIP is a common way of transforming an IP address to a longitude and latitude.Â 

GeoIP is roughly accurate on the city level globally and neighborhood level in selected countries. Itâ€™s not as great as an actual GPS location from your phone, but itâ€™s much more precise than just a country, state, or province. So thereâ€™s a lot of resolution between the precision of the longitude and latitude from GeoIP and the default maps you get in Kibana.

This level of detail can be very useful for driving decision-making.Â For example, say you want to spin up a marketing campaign based on the locations of your users or show executive stakeholders which metro areas you see are experiencing an uptick of traffic.

_GeoIP databases contain latitude and longitude coordinates located near the center of the region or subdivision in which the IP address is located. If you rely on longitude and latitude data from IP geolocation, this may sometimes give misleading results. For example, if GeoIP has identified that an IP address is in the United States, but MaxMind doesn't have data on which state the IP address is in, it will return longitude and latitude near the geographic center of the United States (e.g., Kansas).

GeoIP's longitude and latitude data can be combined with its `accuracy_radius` data to help combat false confidence in its geolocation coordinates._ _You can learn more about [the accuracy of GeoIP on our Support Center](https://support.maxmind.com/geoip-faq/specifications-and-implementation/how-accurate-is-geoip2/)._

That kind of scale in the United States is often captured with what the Census Bureau calls the Combined Statistical Area (CSA). It is roughly equivalent with how people intuitively think of which urban area they live in.Â **It does not necessarily coincide with state or city boundaries.**

This subdivision is central to many of the Federal Governmentâ€™s policies, such as making cost-of-living adjustments to fiscal benefits. CSAs generally share the same telecom providers and ad networks. New fast food franchises expand to a CSA rather than a particular city or municipality. Basically, people in the same CSA shop in the same IKEA.

Assigning a spatial identifier to a feature based on its location is calledÂ **reverse geocoding**Â orÂ **spatial joining**. Itâ€™s one of the most common operations in geographic information systems (GIS).Â 

In the Elastic Stack, this reverse-geocoding functionality resides within Elasticsearch via theÂ `enrich`Â processor. Here we're going to use Kibana to manage these processors and then create maps and visualizations.Â In the tutorial below, we will use CSA boundaries to illustrate reverse geocoding.

## Reverse geocoding with the Elastic Stack

### Step 1: Indexing the geospatial data

This will probably be the most custom part of any solution, so weâ€™ll skip it ðŸ˜œ. Most integrations can rely on theÂ [GeoIP processor](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/geoip-processor.html)Â to transform an IP location into aÂ `geo_point`Â field.

Whatever process you have used to index your data, youâ€™ll have a document using theÂ [ECS schema](https://www.elastic.co/guide/en/ecs/current/ecs-geo.html)Â that will contain two sets of fields created by the GeoIP processor:Â Â 

- destination.geo.\* for where requests are going (usually a data center)
- client.geo.\* for the origin of the request, sometimes calledÂ `origin.geo.*`.

The relevant bit here is thatÂ `*.geo.location`Â field. It contains theÂ **longitude**Â andÂ **latitude**Â of the device.Â 

For the rest of this tutorial, weâ€™ll use theÂ `kibana_sample_data_logs`Â index that comes with Kibana, since thatâ€™s quicker to follow along with. The critical part for reverse geocoding is the presence of the longitude/latitude information and lessÂ _how_Â that longitude/latitude field was created.Â 

### Step 2**:**Â Indexing the boundaries

To get the CSA boundary data, download theÂ [Cartographic Boundary shapefile (.shp)](https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html)Â from the Census Bureauâ€™s website.Â 

To use it in Kibana, we need it as a GeoJSON format. I used QGIS to convert it to GeoJSON. Check out thisÂ [helpful tutorial](https://gist.github.com/YKCzoli/b7f5ff0e0f641faba0f47fa5d16c4d8d)Â if you'd like to do the same.

Once you have your GeoJSON file, go to Maps in Kibana and upload the data using theÂ [GeoJSON uploader](https://www.elastic.co/guide/en/kibana/7.10/indexing-geojson-data-tutorial.html).Â 

Zoomed in on the result, we get a sense of what exactly constitutes a metro area in the eyes of the Census Bureau. I added some tooltip fields using theÂ **Tooltip Fields**Â in the layer editor.

![](images/blog-custom-map-boundaries-3-1024x513.jpg)

This upload created our CSA index containing the shapes weâ€™ll use for reverse geocoding.

### Step 3: Reverse geocoding with a pipeline

In order to create our pipeline, we first need to create the reverse geocoder. We can do this byÂ [creating a geo\_match enrichment policy](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/geo-match-enrich-policy-type.html).Â 

Run the following from Dev Tools in Kibana:

```json
// PUT /_enrich/policy/csa\_lookup
{
  "geo_match": {
    "indices": "csa",
    "match_field": "coordinates",
    "enrich_fields": [ "GEOID", "NAME"]
  }
}
```

```json
// POST /_enrich/policy/csa_lookup/_execute
```

This creates an enrich policy calledÂ `csa_lookup`. It uses theÂ `coordinates`Â field which contains the shapes (it has aÂ `geo_shape`Â field-type). The policy will enrich other documents with theÂ `GEOID`Â andÂ `NAME`Â fields. It also automatically attaches theÂ `coordinates`Â field. TheÂ `_execute`Â call is required for initializing the policy.

Then weâ€™ll integrate this reverse-geocoder into a pipeline.

```json
// PUT /_ingest/pipeline/lonlat-to-csa
{
  "description": "Reverse geocode longitude-latitude to combined statistical area",
  "processors": [
    {
      "enrich": {
        "field": "geo.coordinates",
        "policy_name": "csa\_lookup",
        "target_field": "csa",
        "ignore_missing": true,
        "ignore_failure": true,
        "description": "Lookup the csa identifier"
      }
    },
    {
      "remove": {
        "field": "csa.coordinates",
        "ignore_missing": true,
        "ignore_failure": true,
        "description": "Remove the shape field"
      }
    }
  ]
}
```

Our pipeline consists of two processors:

1. The first is theÂ `enrich`Â processor we just created. It references ourÂ `csa_lookup`Â policy. It creates a new fieldÂ `csa`Â that contains the CSA identifiers (GEOID, NAME) and the CSA geometry (coordinates).
2. The second is aÂ `remove`Â processor that removes the CSA geometry field. (We donâ€™t need it since we are only interested in the identifiers).

### Step 4: Running the pipeline on all your documents

Now that the pipeline is created, we can start using it. And a great thing about pipelines isÂ **you can run them on your existing data**.

WithÂ [\_reindex](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/docs-reindex.html#reindex-with-an-ingest-pipeline), you can create a new index with a copy of your newly enriched documents:Â 

```json
// POST \_reindex
{
  "source": {
    "index": "kibana_sample_data_logs"
  },
  "dest": {
    "index": "dest",
    "pipeline": "lonlat-to-csa"
  }
}
```

WithÂ [\_update\_by\_query](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/docs-update-by-query.html#docs-update-by-query-api-ingest-pipeline), all the documents are enriched in place:

```json
// POST kibana\_sample\_data\_logs/\_update\_by\_query?pipeline=lonlat-to-csa
```

### Step 5: Running the pipeline on new documents at ingest

All the existing docs are updated. Now we need to make sure we also use this pipeline when indexing new documents:

```json
// POST kibana\_sample\_data\_logs/\_doc/testdoc?pipeline=lonlat-to-csa
{
  "geo": {
    "coordinates": {
      "lon": -85.7585,
      "lat": 38.2527
    }
  }
}
```

Let's test it out:

```json
// GET kibana_sample_data_logs/_doc/testdoc
```

You can also setup a default pipeline to have this reverse geocoding done for each incoming document by default:

```json
// PUT kibana_sample_data_logs/_settings
{
  "index": {
    "default_pipeline": "lonlat-to-csa"
  }
}
```

### Step 6: Creating a map

Back in the Maps app, clickÂ **Add layer**. Then selectÂ **Choropleth Layer**:

![](images/blog-custom-map-boundaries-4.png)

Weâ€™ll select our CSA -layer (these are the shapes), and join them by the uniqueÂ `GEOID`Â identifier. Then weâ€™ll join the aggregate info from our request index. The join field here isÂ `csa.GEOID`, which was created by the pipeline.

After changing the default color ramp from green to red and adding some tooltip fields, we can now create our map. In this case, it shows a few hotspots in the Dallas, Indianapolis, and New York metropolitan areas.

![](images/blog-custom-map-boundaries-5-1024x672.jpg)

![](images/blog-custom-map-boundaries-6-1024x513.jpg)

## Get started today

Hopefully this got you thinking about how to use a reverse geocoder. Itâ€™s an incredibly powerful tool to create custom maps and gain new insights in your data.Â Â If you're not already using Elastic Maps, try it outÂ [free in Elastic Cloud](https://www.elastic.co/cloud).Â For any feedback and questions, ourÂ [Discuss forums](https://discuss.elastic.co/)Â are the perfect venue. And if you find yourself breaking the boundaries (ha!) of your old mapping limitations, show us what you made! Connect with us in the forums orÂ [@ us on Twitter](https://twitter.com/elastic).
